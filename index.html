<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TESA – Torque Assistant MVP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#05060a;
      --panel:#0b0d14;
      --panel2:#070813;
      --border:#232530;
      --text:#f5f5f7;
      --sub:#a5a7b3;
      --muted:#6f7380;
      --accent:#4f8cff;
      --accent2:#9fddff;
      --danger:#ff4f6a;
      --ok:#27e49f;
      --r:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;
      background:radial-gradient(circle at top,#141622 0,#05060a 55%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:stretch;
    }
    .wrap{
      width:100%;
      max-width:760px;
      padding:18px 14px 24px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{display:flex;align-items:center;gap:10px}
    .mark{
      width:34px;height:34px;border-radius:12px;
      background:radial-gradient(circle at 30% 30%,var(--accent2),var(--accent));
      display:flex;align-items:center;justify-content:center;
      color:#05060a;font-weight:800;
      box-shadow:0 0 24px rgba(79,140,255,.65);
    }
    .brandText .t1{
      font-weight:700;letter-spacing:.08em;font-size:12px;
      text-transform:uppercase;color:var(--sub);
      line-height:1.1;
    }
    .brandText .t2{
      font-size:11px;color:var(--muted);
      line-height:1.1;margin-top:2px;
    }
    .badge{
      padding:7px 10px;border-radius:999px;
      border:1px solid var(--border);
      font-size:11px;color:var(--sub);
      background:rgba(12,14,22,.9);
      display:inline-flex;align-items:center;gap:7px;
      white-space:nowrap;
    }
    .dot{width:6px;height:6px;border-radius:999px;background:var(--ok);box-shadow:0 0 10px rgba(39,228,159,.7)}

    .card{
      background:linear-gradient(145deg,var(--panel),var(--panel2));
      border:1px solid var(--border);
      border-radius:var(--r);
      padding:14px;
      position:relative;
      overflow:hidden;
      box-shadow:0 18px 45px rgba(0,0,0,.6);
    }
    .card::before{
      content:"";
      position:absolute;inset:-40%;
      background:radial-gradient(circle at top left,rgba(79,140,255,.12),transparent 60%);
      pointer-events:none;
      opacity:.9;
    }
    .card > *{position:relative;z-index:1}

    /* Voice center */
    .voiceArea{
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      text-align:center;
      padding:8px 6px 4px;
    }

    .micBig{
      width:104px;height:104px;border-radius:999px;
      border:1px solid rgba(255,255,255,.08);
      background:radial-gradient(circle at 30% 25%,var(--accent2),var(--accent));
      box-shadow:0 16px 40px rgba(79,140,255,.55), 0 0 18px rgba(79,140,255,.35);
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;
      transition:transform .08s ease, box-shadow .08s ease, opacity .12s ease;
    }
    .micBig:active{transform:scale(.97)}
    .micBig[disabled]{opacity:.35;cursor:not-allowed;box-shadow:none}
    .micBig svg{width:34px;height:34px}
    .hint{
      font-size:12px;color:var(--sub);
      line-height:1.35;
    }
    .hint b{color:#c2d5ff}
    .status{
      min-height:16px;
      font-size:11px;
      color:var(--sub);
    }
    .status.active{color:#c2d5ff}
    .status.error{color:var(--danger)}

    /* Minimal text fallback */
    .fallbackRow{
      width:100%;
      display:flex;
      gap:8px;
      margin-top:2px;
    }
    .q{
      flex:1;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(5,6,12,.9);
      padding:10px 12px;
      color:var(--text);
      font-size:13px;
      outline:none;
    }
    .q::placeholder{color:#5e6270}
    .send{
      width:44px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      color:var(--text);
      cursor:pointer;
      display:flex;align-items:center;justify-content:center;
      transition:transform .08s ease, border-color .12s ease;
    }
    .send:hover{border-color:rgba(79,140,255,.6)}
    .send:active{transform:scale(.98)}
    .send svg{width:18px;height:18px}

    /* step list shown in the headline area (no top divider) */
    .stepList.inline{
      margin-top: 8px;
      padding-top: 0;
      border-top: none;
    }

    /* Result card */
    .resultTop{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      margin-bottom:10px;
    }
    .resultTitle{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:.09em;
      color:var(--sub);
    }
    .controls{
      display:flex;gap:8px;
    }
    .pillBtn{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      color:var(--text);
      font-size:11px;
      cursor:pointer;
    }
    .pillBtn:hover{border-color:rgba(79,140,255,.6)}
    .pillBtn:active{transform:scale(.99)}
    .pillBtn[disabled]{opacity:.35;cursor:not-allowed}

    .partName{
      font-size:16px;
      font-weight:700;
      line-height:1.2;
      margin:2px 0 8px;
    }
    .torqueBig{
      font-size:34px;
      font-weight:800;
      letter-spacing:-.02em;
      line-height:1;
      margin:0 0 8px;
    }
    .torqueUnit{
      font-size:14px;
      font-weight:700;
      color:#c2d5ff;
      margin-left:6px;
    }
    .subLine{
      font-size:12px;
      color:var(--sub);
      line-height:1.4;
      margin-top:2px;
    }
    .metaRow{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:10px;
    }
    .meta{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 9px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      font-size:10px;
      color:var(--sub);
    }
    .meta .mDot{width:6px;height:6px;border-radius:999px;background:var(--accent)}
    .notes{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(255,255,255,.06);
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .note{
      font-size:12px;
      color:#d7d8df;
      line-height:1.35;
    }
    .empty{
      font-size:13px;
      color:#888b96;
      line-height:1.4;
    }

    /* Emphasized chemistry line (threadlock/lube/sealant) */
    .chemLine{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(79,140,255,.35);
      background: rgba(79,140,255,.12);
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .chemItem{
      font-size: 13px;
      color: #eef2ff;
      line-height: 1.25;
    }
    .chemKey{
      font-weight: 800;
      letter-spacing: .02em;
      color: #cfe0ff;
    }

    /* Multi-step list: all same size */
    .stepList{
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,.06);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .stepRow{
      display: flex;
      gap: 10px;
      align-items: baseline;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.06);
      background: rgba(7,9,16,.55);
    }
    .stepTag{
      flex: 0 0 auto;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: #c2d5ff;
    }
    .stepVal{
      flex: 1 1 auto;
      font-size: 16px;        /* <= 모든 step 동일 크기 */
      font-weight: 800;
      letter-spacing: -0.01em;
      color: var(--text);
      line-height: 1.15;
    }
    /* Multi-step: emphasize values slightly */
    .stepList.multi .stepVal{
      font-size: 20px;   /* 기존 16px → 살짝 키움 */
      font-weight: 900;  /* 가독성 강화 (선택) */
    }

    .moreInfoBar{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(7,9,16,.55);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .moreInfoText{font-size:12px;color:#d7d8df;line-height:1.25}
    .moreInfoBtns{display:flex;gap:8px}
    .moreBtn{
      padding:7px 10px;border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      color:var(--text);
      font-size:11px;
      cursor:pointer;
    }
    .moreBtn:hover{border-color:rgba(79,140,255,.6)}

    /* Tools + Notes block (between torque/steps and chemistry line) */
    .infoBlock{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(7,9,16,.55);
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .infoLine{
      font-size: 12px;
      color: #d7d8df;
      line-height: 1.35;
    }
    .infoKey{
      font-weight: 800;
      letter-spacing: .02em;
      color: #cfe0ff;
    }

    /* Candidate chooser (safety rail #3) */
    .candidates{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:10px;
    }
    .candBtn{
      width:100%;
      text-align:left;
      border-radius:14px;
      border:1px solid var(--border);
      background:rgba(7,9,16,.75);
      color:var(--text);
      padding:10px 12px;
      cursor:pointer;
      font-size:12px;
      line-height:1.25;
    }
    .candBtn:hover{border-color:rgba(79,140,255,.6)}
    .candSub{display:block;margin-top:4px;font-size:11px;color:var(--sub)}
  
    .itemNumber{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(7,9,16,.45);
      font-size:12px;
      line-height:1.35;
    }
    .itemNumber .itemLabel{
      color: var(--muted);
      font-weight:700;
      margin-right:6px;
    }
    .refImages{
      margin-top:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .refImage{
      width:100%;
      max-width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(7,9,16,.35);
    }

</style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="mark">T</div>
        <div class="brandText">
          <div class="t1">TESA</div>
          <div class="t2">Tech Spec Assitant</div>
        </div>
      </div>
      <div class="badge" id="modelBadge">
        <span class="dot"></span>
        Loading model…
      </div>
    </header>

    <!-- Voice-first input -->
    <section class="card">
      <div class="voiceArea">
        <button id="micBig" class="micBig" type="button" aria-label="Speak">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path fill="#05060a" d="M12 14a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3z"/>
            <path fill="#05060a" d="M17 11a1 1 0 1 0-2 0 3 3 0 0 1-6 0 1 1 0 1 0-2 0 5.002 5.002 0 0 0 4 4.9V18H9a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-2v-2.1A5.002 5.002 0 0 0 17 11z"/>
          </svg>
        </button>

        <div class="hint">
          Tap mic and ask for torque spec<br>
	  <b>e.g. “brake caliper”</b>
        </div>

        <div id="statusLine" class="status"></div>

        <div class="fallbackRow">
          <input id="questionInput" class="q" type="text"
                 placeholder="Type here (fallback)… e.g. brake caliper"
                 autocomplete="off" />
          <button id="sendBtn" class="send" type="button" aria-label="Ask">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path fill="currentColor" d="M2 21l21-9L2 3v7l15 2-15 2v7z"/>
            </svg>
          </button>
        </div>
      </div>
    </section>

    <!-- Result -->
    <section class="card" id="resultCard">
      <div class="resultTop">
        <div class="resultTitle">Result</div>
        <div class="controls">
          <button id="repeatBtn" class="pillBtn" type="button" disabled>Repeat</button>
          <button id="stopBtn" class="pillBtn" type="button" disabled>Stop</button>
        </div>
      </div>

      <div id="resultBody" class="empty">
        Waiting for your first question.
      </div>
    </section>
  </div>

  <script>
    // =========================
    // Data + Safety rails
    // =========================
    const DATASET_FILE = "panigale_v2_torque_2020-2025_fin.json";

    const GENERIC_WORDS = [
      "bolt","bolts","screw","screws","nut","nuts","washer","washers",
      "pin","pins","clip","clips","fastener","fasteners",
      "torque","tightening","spec","specs","value","values"
    ];

    const MIN_SCORE_TO_ANSWER = 2;   // score too low → refuse
    const MIN_GAP_TO_ANSWER   = 2;   // best-second gap too small → ambiguous
    const MAX_CANDIDATES_UI   = 3;

    let torqueData = [];
    let bikeMeta = null;

    // Speech
    let recognition = null;
    let recognizing = false;

    // TTS
    let lastSpokenText = "";
    let lastSpokenEnabled = false;

    // DOM
    const badgeEl = document.getElementById("modelBadge");
    const statusLine = document.getElementById("statusLine");
    const micBig = document.getElementById("micBig");
    const questionInput = document.getElementById("questionInput");
    const sendBtn = document.getElementById("sendBtn");
    const resultBody = document.getElementById("resultBody");
    const repeatBtn = document.getElementById("repeatBtn");
    const stopBtn = document.getElementById("stopBtn");

    function setStatus(text, active=false, isError=false){
      statusLine.textContent = text || "";
      statusLine.classList.toggle("active", !!active);
      statusLine.classList.toggle("error", !!isError);
    }

    function getSignificantWords(str){
      return String(str || "")
        .toLowerCase()
        .split(/[^a-z0-9]+/)
        .filter(w => w.length > 2 && !GENERIC_WORDS.includes(w));
    }

    async function loadTorqueData(){

try{
  setStatus("Loading dataset…", true, false);
  const res = await fetch(DATASET_FILE, { cache: "no-store" });
  if (!res.ok){
    throw new Error(`HTTP ${res.status} while fetching ${DATASET_FILE}`);
  }
  const data = await res.json();

  // Support both schemas:
  // (A) legacy: { manufacturer, model, year_start, year_end, torque_data: [...] }
  // (B) current: { dataset: { make, model, years:{from,to} }, items:[...] }
  const meta = extractDatasetMeta(data);
  bikeMeta = meta;
  torqueData = Array.isArray(meta.items) ? meta.items : [];

  const make = meta.make || "Unknown";
  const model = meta.model || "Model";
  const yFrom = meta.year_from ?? "";
  const yTo   = meta.year_to ?? "";

  badgeEl.innerHTML = `<span class="dot"></span>${escapeHtml(make)} ${escapeHtml(model)} · ${escapeHtml(String(yFrom))}–${escapeHtml(String(yTo))}`;
  setStatus(`Ready. (${torqueData.length} items)`, true, false);
} catch (e){
  console.error(e);
  setStatus("Failed to load dataset. Use a local server (python http.server).", true, true);
}
    }


    
// -------------------------
// Schema helpers
// -------------------------
function extractDatasetMeta(data){
  // Current schema
  if (data && typeof data === "object" && data.dataset && Array.isArray(data.items)){
    const ds = data.dataset || {};
    const years = ds.years || {};
    return {
      make: ds.make ?? ds.manufacturer ?? ds.brand ?? "Unknown",
      model: ds.model ?? "Model",
      year_from: years.from ?? years.start ?? ds.year_start ?? "",
      year_to: years.to ?? years.end ?? ds.year_end ?? "",
      items: data.items
    };
  }

  // Legacy schema
  return {
    make: data?.manufacturer ?? data?.make ?? "Unknown",
    model: data?.model ?? "Model",
    year_from: data?.year_start ?? data?.year_from ?? "",
    year_to: data?.year_end ?? data?.year_to ?? "",
    items: Array.isArray(data?.torque_data) ? data.torque_data : []
  };
}

function splitList(val){
  if (val == null) return [];
  if (Array.isArray(val)) return val.map(x => String(x ?? "").trim()).filter(Boolean);
  return String(val)
    .split(/[;,]+/)
    .map(s => s.trim())
    .filter(Boolean);
}


function getExtraNotesList(item){
  const v = item?.extra_notes;
  if (v == null) return [];
  if (Array.isArray(v)) return v.map(x => String(x ?? "").trim()).filter(Boolean);
  const s = String(v).trim();
  return s ? [s] : [];
}


function getSpecialTools(item){
  // Preferred: array of objects [{special_tool_name, special_tool_number}, ...]
  if (Array.isArray(item?.special_tools)){
    return item.special_tools.map(t => ({
      special_tool_name: (t?.special_tool_name ?? t?.name ?? "").toString().trim(),
      special_tool_number: (t?.special_tool_number ?? t?.number ?? t?.tool_number ?? "").toString().trim()
    })).filter(t => t.special_tool_name || t.special_tool_number);
  }

  // Current dataset fields: special_tool_numbers / special_tool_name (strings)
  const nums = splitList(item?.special_tool_numbers ?? item?.special_tool_number ?? item?.tool_number);
  const names = splitList(item?.special_tool_name ?? item?.special_tool_names ?? item?.tool_name);

  const out = [];
  const n = Math.max(nums.length, names.length);
  for (let i=0; i<n; i++){
    out.push({
      special_tool_name: names[i] || "",
      special_tool_number: nums[i] || ""
    });
  }
  return out.filter(t => t.special_tool_name || t.special_tool_number);
}

function scoreItem(queryLower, qSig, item){
      let textParts = [];
      if (item.component_name) textParts.push(item.component_name);
      if (Array.isArray(item.common_name)) textParts.push(item.common_name.join(" "));
      const fullText = textParts.join(" ").toLowerCase();
      if (!fullText) return 0;

      // hit count
      let hits = 0;
      for (const w of qSig) if (fullText.includes(w)) hits++;
      let score = hits;

      // component_name bonus
      if (item.component_name){
        const cn = item.component_name.toLowerCase();
        if (queryLower === cn) score += 5;
        else if (queryLower.includes(cn) || cn.includes(queryLower)) score += 2;
      }

      // common_name bonus
      if (Array.isArray(item.common_name)){
        for (const aRaw of item.common_name){
          const a = String(aRaw || "").toLowerCase();
          if (!a) continue;
          if (queryLower === a) score += 4;
          else if (queryLower.includes(a) || a.includes(queryLower)) score += 1;
        }
      }
      return score;
    }

    function findCandidates(query){
      const qLower = query.toLowerCase();
      const qSig = getSignificantWords(query);
      if (!qSig.length) return [{__special:"NO_SIG_WORDS"}];

      const scored = [];
      for (const item of torqueData){
        const s = scoreItem(qLower, qSig, item);
        if (s > 0) scored.push({item, score:s});
      }
      scored.sort((a,b)=>b.score-a.score);
      return scored;
    }

    // =========================
    // Result rendering (voice-first)
    // =========================
    function renderEmpty(text){
      resultBody.className = "empty";
      resultBody.innerHTML = text;
      setRepeatStop(false);
    }

    function setRepeatStop(enabled){
      repeatBtn.disabled = !enabled;
      stopBtn.disabled = !enabled;
      lastSpokenEnabled = enabled;
    }

    function stopSpeak(){
      if ("speechSynthesis" in window){
        window.speechSynthesis.cancel();
      }
    }

    function speak(text){
      lastSpokenText = text || "";
      setRepeatStop(!!lastSpokenText);

      if (!("speechSynthesis" in window) || !text) return;
      stopSpeak();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "en-US";
      u.rate = 1.0;
      u.pitch = 1.0;
      window.speechSynthesis.speak(u);
    }

    function speakNumbersDigitByDigit(text){
      if (text == null) return "";
      const s = String(text);

      // 문자열 안의 연속 숫자(\d+)만 찾아서 "2 4 3" 형태로 변환
      return s.replace(/\d+/g, (num) => num.split("").join(" "));
    }

function buildSpokenAnswerParts(item){
  if (!item) return { base:"No matching fastener found.", info:"" };

  const name = item.component_name || "this fastener";
  const hasSteps = Array.isArray(item.torque_steps) && item.torque_steps.length > 0;

  // Detect bolt-size variants: ALL step labels are like M8, M6, M10...
  let isBoltSizeVariant = false;
  if (hasSteps){
    const labels = item.torque_steps.map((s, idx) => {
      const raw = (s.step != null ? String(s.step) : String(idx + 1)).trim();
      return raw;
    });
    isBoltSizeVariant = labels.length > 0 && labels.every(l => /^m\d+$/i.test(l));
  }

  const baseParts = [];
  const infoParts = [];

  // partName: speak name only
  baseParts.push(`${name}.`);

  // ---- Torque / steps ----
  if (hasSteps && isBoltSizeVariant){
    baseParts.push(`Torque by size.`);
    item.torque_steps.forEach((s, idx) => {
      const size = (s.step != null ? String(s.step) : String(idx + 1)).trim().toUpperCase();
      const seg = [];
      if (s.torque_nm != null) seg.push(`${s.torque_nm} newton meters`);
      if (s.angle_deg != null) seg.push(`plus ${s.angle_deg} degrees`);
      if (seg.length) baseParts.push(`${size}: ${seg.join(", ")}.`);
      else if (s.raw) baseParts.push(`${size}: ${s.raw}.`);
    });
  } else if (hasSteps){
    // baseParts.push(`Tightening procedure.`); // removed per spec
    item.torque_steps.forEach((step, idx) => {
      let label = (step.step != null ? String(step.step) : String(idx + 1)).trim();
      if (/^\d+$/.test(label)) label = `Step ${label}`;
      else if (/^step\s*\d+$/i.test(label)){
        const m = label.match(/(\d+)/);
        if (m) label = `Step ${m[1]}`;
      }
      if (step.torque_nm != null && step.angle_deg != null){
        baseParts.push(`${label}. ${step.torque_nm} newton meters, then add ${step.angle_deg} degrees.`);
      } else if (step.torque_nm != null){
        baseParts.push(`${label}. ${step.torque_nm} newton meters.`);
      } else if (step.angle_deg != null){
        baseParts.push(`${label}. Add ${step.angle_deg} degrees.`);
      } else if (step.raw){
        baseParts.push(`${label}. ${step.raw}.`);
      }
    });
  } else if (item.torque_nm_single != null){
    baseParts.push(`${item.torque_nm_single} newton meters.`);
  } else {
    baseParts.push(`Torque is not specified in this dataset.`);
  }

  // ---- Chemistry (values only) ----
    const chemVals = [];

    // threadlock: 숫자만 digit-by-digit
    if (item.threadlock) {
      chemVals.push(speakNumbersDigitByDigit(item.threadlock));
    }

    // lubrication: symbol 그대로 (변경 없음)
    const lubeSpoken = item.lubrication_symbol || item.lubrication;
    if (lubeSpoken) {
      chemVals.push(String(lubeSpoken));
    }

    // sealant: 숫자만 digit-by-digit
    if (item.sealant) {
      chemVals.push(speakNumbersDigitByDigit(item.sealant));
    }

    if (chemVals.length) {
      baseParts.push(`Apply ${chemVals.join(", ")}.`);
    }


  // ---- Info block (spoken only when user says YES) ----
  // Special tools speaking rules:
  // - name+number OR name only: "<name> is required."
  // - number only: "Special tool <number> is required."
  // - neither: say nothing
  const _tools = getSpecialTools(item);
  if (_tools.length){
    _tools.forEach(t => {
      const toolName = (t?.special_tool_name ?? "").toString().trim();
      const toolNum  = (t?.special_tool_number ?? "").toString().trim();

      if (toolName){
        infoParts.push(`${toolName} is required.`);
      } else if (toolNum){
        infoParts.push(`Special tool ${toolNum} is required.`);
      }
    });
  }


  // Sequence: read value only
  if (item.tightening_seq){
    infoParts.push(String(item.tightening_seq).trim().endsWith(".")
      ? String(item.tightening_seq).trim()
      : `${String(item.tightening_seq).trim()}.`
    );
  }

  // Note: read value only
  const _notes = getExtraNotesList(item);
  if (_notes.length){
    _notes.forEach(note => {
      const n = String(note || "").trim();
      if (!n) return;
      // add a period if it doesn't already end in ., ?, !
      infoParts.push(/[.?!]$/.test(n) ? n : (n + "."));
    });
  }

  return {
    base: baseParts.join(" "),
    info: infoParts.join(" ")
  };
}

    function renderResult(item, info){
      const name = item.component_name || "Unknown fastener";

      // ----- Chemistry line (threadlock / lube / sealant) -----
      const chemItems = [];
      if (item.threadlock)  chemItems.push({k:"Threadlock", v:item.threadlock});

        // ✅ show symbol instead of full lubrication text
      const lubeDisplay = item.lubrication_symbol || item.lubrication;
      if (lubeDisplay) chemItems.push({k:"Lubrication", v:lubeDisplay});

      if (item.sealant)     chemItems.push({k:"Sealant", v:item.sealant});

      // ----- Steps normalize -----
      const hasSteps = Array.isArray(item.torque_steps) && item.torque_steps.length > 0;
      const rows = [];
      if (hasSteps){
        item.torque_steps.forEach((s, idx) => {
          const rawLabel = (s.step != null ? String(s.step) : String(idx + 1)).trim();
          const parts = [];
          if (s.torque_nm != null) parts.push(`${s.torque_nm} Nm`);
          if (s.angle_deg != null) parts.push(`+ ${s.angle_deg}°`);
          const value = parts.length ? parts.join(" ") : (s.raw || "Follow manual");
          rows.push({ label: rawLabel, value });
        });
      }

      const isBoltSizeVariant =
        rows.length > 0 &&
        rows.every(r => /^m\d+$/i.test(r.label));

      const hasSingle = (item.torque_nm_single != null);

      // ----- Pills: Type, Thread, Group, Score (in that order) -----
      const pills = [];

      // Type
      if (rows.length) pills.push("Type: multi");
      else if (hasSingle) pills.push("Type: single");

      // Thread
      if (item.thread_spec) pills.push(`Thread: ${item.thread_spec}`);

      // Group
      if (item.group) pills.push(`Group: ${item.group}`);

      // Score
      if (info && typeof info.bestScore === "number") pills.push(`Score: ${info.bestScore}`);

      // ----- Special tools + Extra notes (new block) -----
      const toolLines = [];
      const _toolsForScreen = getSpecialTools(item);
      if (_toolsForScreen.length){
        _toolsForScreen.forEach(t=>{
          const toolName = (t?.special_tool_name ?? "").toString().trim();
          const toolNum  = (t?.special_tool_number ?? "").toString().trim();

          // Screen exposure rules:
          // - name+number: "name - number"
          // - name only: "name"
          // - number only: "number"
          if (toolName && toolNum) toolLines.push(`${toolName} - ${toolNum}`);
          else if (toolName) toolLines.push(`${toolName}`);
          else if (toolNum) toolLines.push(`${toolNum}`);
        });
      }
      const extraNotes = getExtraNotesList(item);

      // ----- Build HTML -----
      let html = `<div class="partName">${escapeHtml(name)}</div>`;

      // ✅ multi-step: show steps in the single-torque area
      if (rows.length){
        html += `<div class="stepList multi" style="margin-top:8px;padding-top:0;border-top:none;">`;

        rows.forEach(r => {
          let tag = r.label;

          if (!isBoltSizeVariant){
            if (/^\d+$/.test(tag)) tag = `Step ${tag}`;
            else if (/^step\s*\d+$/i.test(tag)) {
              const m = tag.match(/(\d+)/);
              if (m) tag = `Step ${m[1]}`;
            }
          }

          html += `
            <div class="stepRow">
              <div class="stepTag">${escapeHtml(tag)}</div>
              <div class="stepVal">${escapeHtml(r.value)}</div>
            </div>
          `;
        });

        html += `</div>`;
      } else {
        // ✅ single: big torque number only (no "Single torque" line)
        if (hasSingle){
          html += `
            <div class="torqueBig">
              ${escapeHtml(String(item.torque_nm_single))}<span class="torqueUnit">Nm</span>
            </div>
          `;
        } else {
          html += `
            <div class="torqueBig">—</div>
          `;
        }
      }

      // Chemistry line (threadlock/lube/sealant)
      if (chemItems.length){
        html += `<div class="chemLine">` + chemItems.map(ci => (
          `<div class="chemItem"><span class="chemKey">${escapeHtml(ci.k)}:</span> ${escapeHtml(ci.v)}</div>`
        )).join("") + `</div>`;
      }

      // ✅ Info block (Special tool → Tightening sequence → Extra notes)
      const _toolsForInfo = getSpecialTools(item);
      const hasToolDataForInfo = _toolsForInfo.length > 0;
      const hasSeqDataForInfo  = !!(item.tightening_seq && String(item.tightening_seq).trim());
      const hasNoteDataForInfo = getExtraNotesList(item).length > 0;
      const hasInfoBlock = (hasToolDataForInfo || hasSeqDataForInfo || hasNoteDataForInfo);

if (hasInfoBlock){
        html += `<div class="infoBlock" id="infoBlock">`;

        // 1) Special tool
        const _toolsInfo = getSpecialTools(item);
        if (_toolsInfo.length){
          const toolLines = _toolsInfo.map(t=>{
            const toolName = (t?.special_tool_name ?? "").toString().trim();
            const toolNum  = (t?.special_tool_number ?? "").toString().trim();
            if (toolName && toolNum) return `${toolName} - ${toolNum}`;
            if (toolName) return `${toolName}`;
            if (toolNum) return `${toolNum}`;
            return "";
          }).filter(Boolean);

          if (toolLines.length){
            html += `<div class="infoLine"><span class="infoKey">Special tool:</span> ${escapeHtml(toolLines.join(", "))}</div>`;
          }
        }

        // 2) Tightening sequence
        if (item.tightening_seq){
          html += `<div class="infoLine"><span class="infoKey">Sequence:</span> ${escapeHtml(String(item.tightening_seq))}</div>`;
        }

        // 3) Extra notes
        const _notesForScreen = getExtraNotesList(item);
        if (_notesForScreen.length){
          _notesForScreen.forEach(n=>{
            html += `<div class="infoLine"><span class="infoKey">Note:</span> ${escapeHtml(n)}</div>`;
          });
        }

        html += `</div>`;
      }


      // ----- Item number + reference images (between infoBlock and pills) -----
      const itemNumber = (item?.item_number ?? "").toString().trim();
      if (itemNumber){
        html += `<div class="itemNumber"><span class="itemLabel">Item:</span>${escapeHtml(itemNumber)}</div>`;
      }

      let refImgs = [];
      if (Array.isArray(item?.ref_images)) {
        refImgs = item.ref_images;
      } else if (typeof item?.ref_image === "string") {
        refImgs = item.ref_image.split(";");
      }
      refImgs = (refImgs || []).map(x => (x ?? "").toString().trim()).filter(Boolean);

      if (refImgs.length){
        html += `<div class="refImages">` +
          refImgs.map(fn => `<img class="refImage" src="images/${encodeURIComponent(fn)}" alt="Reference image">`).join("") +
          `</div>`;
      }

      // Meta pills
      if (pills.length){
        html += `<div class="metaRow">` + pills.map(p=>(
          `<span class="meta"><span class="mDot"></span>${escapeHtml(p)}</span>`
        )).join("") + `</div>`;
      }

      // ❌ 기존 하단 notes 섹션은 삭제 (요청사항)

      resultBody.className = "";
      const spoken = buildSpokenAnswerParts(item);

      // Determine whether there is additional info worth reading (gate)
      const hasInfoToRead =
        (getSpecialTools(item).length > 0) ||
        (!!(item.tightening_seq && String(item.tightening_seq).trim())) ||
        (getExtraNotesList(item).length > 0);

if (hasInfoToRead){
        // Add Yes/No gate UI (inserted into DOM)
        html += `
          <div class="moreInfoBar" id="moreInfoBar">
            <div class="moreInfoText">Read additional info?</div>
            <div class="moreInfoBtns">
              <button class="moreBtn" type="button" id="moreYes">Yes</button>
              <button class="moreBtn" type="button" id="moreNo">No</button>
            </div>
          </div>
        `;
      }

      resultBody.className = "";
      resultBody.innerHTML = html;

      if (hasInfoToRead){
        speak(`${spoken.base} Read additional info?`);

        const yesBtn = document.getElementById("moreYes");
        const noBtn  = document.getElementById("moreNo");

        if (yesBtn) yesBtn.addEventListener("click", ()=>{
          speak(spoken.info);
        });

        if (noBtn) noBtn.addEventListener("click", ()=>{
          // hide the gate bar after decision
          const bar = document.getElementById("moreInfoBar");
          if (bar) bar.remove();
          stopSpeak();
        });
      } else {
        // no extra info: just speak base
        speak(spoken.base);
      }

    }

    function renderAmbiguous(cands, info){
      resultBody.className = "";
      const top = cands.slice(0, MAX_CANDIDATES_UI);
      let html = `
        <div class="partName">Multiple matches</div>
        <div class="subLine">Tap the correct one (safer than guessing).</div>
      `;

      if (info && typeof info.bestScore === "number"){
        html += `<div class="metaRow">
          <span class="meta"><span class="mDot"></span>Score: ${escapeHtml(String(info.bestScore))}</span>
          <span class="meta"><span class="mDot"></span>Gap: ${escapeHtml(String(info.gap))}</span>
        </div>`;
      }

      html += `<div class="candidates">` + top.map(({item, score})=>{
        const title = item.component_name || item.id || "Candidate";
        const group = item.group ? ` · ${item.group}` : "";
        return `<button class="candBtn" type="button" data-id="${escapeHtml(String(item.id || ""))}">
          <strong>${escapeHtml(title)}</strong>
          <span class="candSub">Select (score ${escapeHtml(String(score))})${escapeHtml(group)}</span>
        </button>`;
      }).join("") + `</div>`;

      resultBody.innerHTML = html;
      setRepeatStop(false);
      speak("Multiple matches. Please select the correct fastener on the screen.");

      // bind
      const btns = resultBody.querySelectorAll(".candBtn");
      btns.forEach((b, idx)=>{
        b.addEventListener("click", ()=>{
          const chosen = top[idx];
          if (chosen && chosen.item) renderResult(chosen.item, {bestScore: chosen.score});
        });
      });
    }

    function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function normalizeQuery(q){
      let s = String(q || "").toLowerCase();

      const glueMap = {
        "subframe": "sub frame",
        "swingarm": "swing arm",
        "headstock": "head stock",
        "oilpan": "oil pan",
        "wheelbase": "wheel base"
      };

      for (const [k,v] of Object.entries(glueMap)){
        s = s.replaceAll(k, v);
      }

      return s;
    }

    // =========================
    // Query handler (uses safety rails)
    // =========================
    function handleQuery(raw){
      const q = String(raw || "").trim();
      const nq = normalizeQuery(q);
      if (!q){
        setStatus("Say a part name, or type in the box.", true, true);
        renderEmpty("Waiting for your question.");
        return;
      }
      if (!torqueData.length){
        setStatus("Dataset not loaded yet.", true, true);
        renderEmpty("Dataset not loaded yet.");
        return;
      }

      setStatus("Searching…", true, false);

      const candidates = findCandidates(nq);

      // Rail #1: too generic
      if (candidates.length && candidates[0].__special === "NO_SIG_WORDS"){
        setStatus("Too generic. Add a part name.", true, true);
        renderEmpty("Too generic. Include a part name (example: “rear brake caliper”).");
        speak("Too generic. Please include a part name, for example: rear brake caliper.");
        return;
      }

      // No candidates
      if (!candidates.length){
        setStatus("No match in dataset.", true, true);
        renderEmpty("No match. This part may not be in the current dataset.");
        speak("No matching fastener found. This part may not be in the current dataset.");
        return;
      }

      const best = candidates[0];
      const second = candidates[1] || null;
      const bestScore = best.score;
      const gap = second ? (best.score - second.score) : best.score;

      // Rail #2: low score → refuse
      if (bestScore < MIN_SCORE_TO_ANSWER){
        setStatus("Low confidence. Be more specific.", true, true);
        renderEmpty("No confident match. Try a more specific part name (add location/system).");
        speak("No confident match. Try a more specific part name.");
        return;
      }

      // Rail #3: ambiguous → user choose
      if (second && gap < MIN_GAP_TO_ANSWER){
        setStatus("Ambiguous. Select the correct one.", true, true);
        renderAmbiguous(candidates, {bestScore, gap});
        return;
      }

      // Confident
      setStatus("Match found.", true, false);
      renderResult(best.item, {bestScore, gap});
    }

    // =========================
    // Events
    // =========================
    sendBtn.addEventListener("click", ()=> handleQuery(questionInput.value));
    questionInput.addEventListener("keydown", (e)=>{
      if (e.key === "Enter"){
        e.preventDefault();
        handleQuery(questionInput.value);
      }
    });

    repeatBtn.addEventListener("click", ()=>{
      if (lastSpokenEnabled && lastSpokenText) speak(lastSpokenText);
    });
    stopBtn.addEventListener("click", ()=>{
      stopSpeak();
    });

    // Speech recognition (desktop chrome)
    function initSpeech(){
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition){
        micBig.disabled = true;
        setStatus("Speech recognition not supported here (iPhone Safari limitation). Use keyboard mic.", true, true);
        return;
      }
      recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;

      recognition.onstart = ()=>{
        recognizing = true;
        setStatus("Listening…", true, false);
      };
      recognition.onerror = (ev)=>{
        recognizing = false;
        setStatus("Speech error: " + ev.error, true, true);
      };
      recognition.onend = ()=>{
        recognizing = false;
        setStatus("Ready.", true, false);
      };
      recognition.onresult = (ev)=>{
        const t = ev.results[0][0].transcript;
        questionInput.value = t;
        handleQuery(t);
      };
    }

    micBig.addEventListener("click", ()=>{
      if (!recognition) initSpeech();
      if (!recognition) return;

      if (recognizing){
        recognition.stop();
        return;
      }
      recognition.start();
    });

    // Init
    renderEmpty("Waiting for your first question.");
    setStatus("");
    loadTorqueData();
  </script>
</body>
</html>
