<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>TESA – Torque Assistant MVP</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <style>
    :root{
      --bg:#05060a;
      --panel:#0b0d14;
      --panel2:#070813;
      --border:#232530;
      --text:#f5f5f7;
      --sub:#a5a7b3;
      --muted:#6f7380;
      --accent:#4f8cff;
      --accent2:#9fddff;
      --danger:#ff4f6a;
      --ok:#27e49f;
      --r:18px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"SF Pro Text","Segoe UI",sans-serif;
      background:radial-gradient(circle at top,#141622 0,#05060a 55%);
      color:var(--text);
      min-height:100vh;
      display:flex;
      justify-content:center;
      align-items:stretch;
    }
    .wrap{
      width:100%;
      max-width:760px;
      padding:18px 14px 24px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .brand{display:flex;align-items:center;gap:10px}
    .mark{
      width:34px;height:34px;border-radius:12px;
      background:radial-gradient(circle at 30% 30%,var(--accent2),var(--accent));
      display:flex;align-items:center;justify-content:center;
      color:#05060a;font-weight:800;
      box-shadow:0 0 24px rgba(79,140,255,.65);
    }
    .brandText .t1{
      font-weight:700;letter-spacing:.08em;font-size:12px;
      text-transform:uppercase;color:var(--sub);
      line-height:1.1;
    }
    .brandText .t2{
      font-size:11px;color:var(--muted);
      line-height:1.1;margin-top:2px;
    }
    .badge{
      padding:7px 10px;border-radius:999px;
      border:1px solid var(--border);
      font-size:11px;color:var(--sub);
      background:rgba(12,14,22,.9);
      display:inline-flex;align-items:center;gap:7px;
      white-space:nowrap;
    }
    .dot{width:6px;height:6px;border-radius:999px;background:var(--ok);box-shadow:0 0 10px rgba(39,228,159,.7)}

    .card{
      background:linear-gradient(145deg,var(--panel),var(--panel2));
      border:1px solid var(--border);
      border-radius:var(--r);
      padding:14px;
      position:relative;
      overflow:hidden;
      box-shadow:0 18px 45px rgba(0,0,0,.6);
    }
    .card::before{
      content:"";
      position:absolute;inset:-40%;
      background:radial-gradient(circle at top left,rgba(79,140,255,.12),transparent 60%);
      pointer-events:none;
      opacity:.9;
    }
    .card > *{position:relative;z-index:1}

    /* Voice center */
    .voiceArea{
      display:flex;
      flex-direction:column;
      gap:12px;
      align-items:center;
      text-align:center;
      padding:8px 6px 4px;
    }

    .micBig{
      width:104px;height:104px;border-radius:999px;
      border:1px solid rgba(255,255,255,.08);
      background:radial-gradient(circle at 30% 25%,var(--accent2),var(--accent));
      box-shadow:0 16px 40px rgba(79,140,255,.55), 0 0 18px rgba(79,140,255,.35);
      display:flex;align-items:center;justify-content:center;
      cursor:pointer;
      transition:transform .08s ease, box-shadow .08s ease, opacity .12s ease;
    }
    .micBig:active{transform:scale(.97)}
    .micBig[disabled]{opacity:.35;cursor:not-allowed;box-shadow:none}
    .micBig svg{width:34px;height:34px}
    .hint{
      font-size:12px;color:var(--sub);
      line-height:1.35;
    }
    .hint b{color:#c2d5ff}
    .status{
      min-height:16px;
      font-size:11px;
      color:var(--sub);
    }
    .status.active{color:#c2d5ff}
    .status.error{color:var(--danger)}

    /* Minimal text fallback */
    .fallbackRow{
      width:100%;
      display:flex;
      gap:8px;
      margin-top:2px;
    }
    .q{
      flex:1;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(5,6,12,.9);
      padding:10px 12px;
      color:var(--text);
      font-size:13px;
      outline:none;
    }
    .q::placeholder{color:#5e6270}
    .send{
      width:44px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      color:var(--text);
      cursor:pointer;
      display:flex;align-items:center;justify-content:center;
      transition:transform .08s ease, border-color .12s ease;
    }
    .send:hover{border-color:rgba(79,140,255,.6)}
    .send:active{transform:scale(.98)}
    .send svg{width:18px;height:18px}

    /* step list shown in the headline area (no top divider) */
    .stepList.inline{
      margin-top: 8px;
      padding-top: 0;
      border-top: none;
    }

    /* Result card */
    .resultTop{
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      margin-bottom:10px;
    }
    .resultTitle{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:.09em;
      color:var(--sub);
    }
    .controls{
      display:flex;gap:8px;
    }
    .pillBtn{
      padding:7px 10px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      color:var(--text);
      font-size:11px;
      cursor:pointer;
    }
    .pillBtn:hover{border-color:rgba(79,140,255,.6)}
    .pillBtn:active{transform:scale(.99)}
    .pillBtn[disabled]{opacity:.35;cursor:not-allowed}

    .partName{
      font-size:16px;
      font-weight:700;
      line-height:1.2;
      margin:2px 0 8px;
    }
    .torqueBig{
      font-size:34px;
      font-weight:800;
      letter-spacing:-.02em;
      line-height:1;
      margin:0 0 8px;
    }
    .torqueUnit{
      font-size:14px;
      font-weight:700;
      color:#c2d5ff;
      margin-left:6px;
    }
    .subLine{
      font-size:12px;
      color:var(--sub);
      line-height:1.4;
      margin-top:2px;
    }
    .metaRow{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-top:10px;
    }
    .meta{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding:4px 9px;
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      font-size:10px;
      color:var(--sub);
    }
    .meta .mDot{width:6px;height:6px;border-radius:999px;background:var(--accent)}
    .notes{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid rgba(255,255,255,.06);
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .note{
      font-size:12px;
      color:#d7d8df;
      line-height:1.35;
    }
    .empty{
      font-size:13px;
      color:#888b96;
      line-height:1.4;
    }

    /* Emphasized chemistry line (threadlock/lube/sealant) */
    .chemLine{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(79,140,255,.35);
      background: rgba(79,140,255,.12);
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .chemItem{
      font-size: 13px;
      color: #eef2ff;
      line-height: 1.25;
    }
    .chemKey{
      font-weight: 800;
      letter-spacing: .02em;
      color: #cfe0ff;
    }

    /* Multi-step list: all same size */
    .stepList{
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px solid rgba(255,255,255,.06);
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .stepRow{
      display: flex;
      gap: 10px;
      align-items: baseline;
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.06);
      background: rgba(7,9,16,.55);
    }
    .stepTag{
      flex: 0 0 auto;
      font-size: 12px;
      font-weight: 900;
      letter-spacing: .08em;
      text-transform: uppercase;
      color: #c2d5ff;
    }
    .stepVal{
      flex: 1 1 auto;
      font-size: 16px;        /* <= 모든 step 동일 크기 */
      font-weight: 800;
      letter-spacing: -0.01em;
      color: var(--text);
      line-height: 1.15;
      display:flex;
      align-items:baseline;
      gap:6px;
    }
    /* Multi-step: emphasize values slightly */
    .stepList.multi .stepVal{
      font-size: 20px;   /* 기존 16px → 살짝 키움 */
      font-weight: 900;  /* 가독성 강화 (선택) */
    }

    .stepNum{
      font-size:28px;
      font-weight:800;
      letter-spacing:-.02em;
      line-height:1;
    }
    .stepUnit{
      font-size:14px;
      font-weight:700;
      color:#c2d5ff;
    }


    .moreInfoBar{
      margin-top:10px;
      padding:10px 12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background:rgba(7,9,16,.55);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .moreInfoText{font-size:12px;color:#d7d8df;line-height:1.25}
    .moreInfoBtns{display:flex;gap:8px}
    .moreBtn{
      padding:7px 10px;border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      color:var(--text);
      font-size:11px;
      cursor:pointer;
    }
    .moreBtn:hover{border-color:rgba(79,140,255,.6)}

    /* Tools + Notes block (between torque/steps and chemistry line) */
    .infoBlock{
      margin-top: 10px;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(7,9,16,.55);
      text-align: left;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .infoLine{
      font-size: 12px;
      color: #d7d8df;
      line-height: 1.35;
    }
    .infoKey{
      font-weight: 800;
      letter-spacing: .02em;
      color: #cfe0ff;
    }

    /* Candidate chooser (safety rail #3) */
    .candidates{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:10px;
    }
    .candBtn{
      width:100%;
      text-align:left;
      border-radius:14px;
      border:1px solid var(--border);
      background:rgba(7,9,16,.75);
      color:var(--text);
      padding:10px 12px;
      cursor:pointer;
      font-size:12px;
      line-height:1.25;
    }
    .candBtn:hover{border-color:rgba(79,140,255,.6)}
    .candSub{display:block;margin-top:4px;font-size:11px;color:var(--sub)}
  
    .itemNumber{
      margin-top:10px;
      padding:10px 12px;
      border-radius:12px;
      border:1px solid rgba(255,255,255,.08);
      background: rgba(7,9,16,.45);
      font-size:12px;
      line-height:1.35;
    }
    .itemNumber .itemLabel{
      color: var(--muted);
      font-weight:700;
      margin-right:6px;
    }
    .refImages{
      margin-top:10px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .refImage{
      width:100%;
      max-width:100%;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(7,9,16,.35);
    }


    /* === Model selector sheet (MVP) === */
    .sheetOverlay{
      position:fixed;
      inset:0;
      background:rgba(0,0,0,.55);
      display:none;
      align-items:flex-end;
      justify-content:center;
      z-index:999;
      padding:14px;
    }
    .sheetOverlay.show{display:flex}
    .sheet{
      width:100%;
      max-width:760px;
      border-radius:20px 20px 18px 18px;
      border:1px solid var(--border);
      background:linear-gradient(145deg,var(--panel),var(--panel2));
      box-shadow:0 18px 55px rgba(0,0,0,.75);
      overflow:hidden;
    }
    .sheetHeader{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:12px 14px;
      border-bottom:1px solid rgba(255,255,255,.06);
    }
    .sheetTitle{
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:.09em;
      color:var(--sub);
      font-weight:800;
    }
    .sheetClose{
      border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      color:var(--text);
      font-size:11px;
      padding:7px 10px;
      cursor:pointer;
    }
    .sheetClose:hover{border-color:rgba(79,140,255,.6)}
    .sheetBody{
      padding:10px 10px 12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height:62vh;
      overflow:auto;
    }
    .makeLabel{
      margin-top:6px;
      padding:6px 6px 0;
      font-size:11px;
      color:var(--muted);
      letter-spacing:.08em;
      text-transform:uppercase;
    }
    .modelBtn{
      width:100%;
      text-align:left;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.08);
      background:rgba(7,9,16,.55);
      color:var(--text);
      padding:10px 12px;
      cursor:pointer;
      font-size:12px;
      line-height:1.25;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .modelBtn:hover{border-color:rgba(79,140,255,.6)}
    .modelBtn .right{
      flex:0 0 auto;
      font-size:11px;
      color:var(--sub);
      white-space:nowrap;
    }
    .modelBtn.active{
      border-color:rgba(39,228,159,.55);
      box-shadow:0 0 0 2px rgba(39,228,159,.12) inset;
    }
    .badge.clickable{cursor:pointer}
    .badge.clickable:hover{border-color:rgba(79,140,255,.6)}


    /* Small mic button next to model badge */
    .badgeRow{display:flex;align-items:center;gap:8px}
    .micMini{
      width:34px;height:34px;border-radius:999px;
      border:1px solid var(--border);
      background:rgba(9,11,18,.85);
      color:var(--text);
      cursor:pointer;
      display:flex;align-items:center;justify-content:center;
      transition:transform .08s ease, border-color .12s ease, opacity .12s ease;
    }
    .micMini:hover{border-color:rgba(79,140,255,.6)}
    .micMini:active{transform:scale(.98)}
    .micMini[disabled]{opacity:.35;cursor:not-allowed}
    .micMini.listening{
      border-color:rgba(39,228,159,.55);
      box-shadow:0 0 0 2px rgba(39,228,159,.12) inset;
    }
    .micMini svg{width:16px;height:16px}

</style>
</head>

<body>
  <div class="wrap">
    <header>
      <div class="brand">
        <div class="mark">T</div>
        <div class="brandText">
          <div class="t1">TESA</div>
          <div class="t2">Tech Spec Assitant</div>
        </div>
      </div>
      <div class="badgeRow">
      <div class="badge" id="modelBadge">
        <span class="dot"></span>
        Loading…
      </div>
      <button id="modelMicBtn" class="micMini" type="button" aria-label="Switch model by voice" title="Switch model by voice">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path fill="currentColor" d="M12 14a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3z"/>
          <path fill="currentColor" d="M17 11a1 1 0 1 0-2 0 3 3 0 0 1-6 0 1 1 0 1 0-2 0 5.002 5.002 0 0 0 4 4.9V18H9a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-2v-2.1A5.002 5.002 0 0 0 17 11z"/>
        </svg>
      </button>
    </div>
    </header>

    <!-- Voice-first input -->
    <section class="card">
      <div class="voiceArea">
        <button id="micBig" class="micBig" type="button" aria-label="Speak">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path fill="#05060a" d="M12 14a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3z"/>
            <path fill="#05060a" d="M17 11a1 1 0 1 0-2 0 3 3 0 0 1-6 0 1 1 0 1 0-2 0 5.002 5.002 0 0 0 4 4.9V18H9a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-2v-2.1A5.002 5.002 0 0 0 17 11z"/>
          </svg>
        </button>

        <div class="hint">
          Tap mic and ask for torque spec<br>
	  <b>e.g. “brake caliper”</b>
        </div>

        <div id="statusLine" class="status"></div>

        <div class="fallbackRow">
          <input id="questionInput" class="q" type="text"
                 placeholder="Type here (fallback)… e.g. brake caliper"
                 autocomplete="off" />
          <button id="sendBtn" class="send" type="button" aria-label="Ask">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path fill="currentColor" d="M2 21l21-9L2 3v7l15 2-15 2v7z"/>
            </svg>
          </button>
        </div>
      </div>
    </section>

    <!-- Result -->
    <section class="card" id="resultCard">
      <div class="resultTop">
        <div class="resultTitle">Result</div>
        <div class="controls">
          <button id="repeatBtn" class="pillBtn" type="button" disabled>Repeat</button>
          <button id="stopBtn" class="pillBtn" type="button" disabled>Stop</button>
        </div>
      </div>

      <div id="resultBody" class="empty">
        Waiting for your first question.
      </div>
    </section>
  </div>


  <!-- Model selector (tap the model badge) -->
  <div id="sheetOverlay" class="sheetOverlay" role="dialog" aria-modal="true" aria-label="Select model">
    <div class="sheet">
      <div class="sheetHeader">
        <div class="sheetTitle">Select model</div>
        <button id="sheetClose" class="sheetClose" type="button">Close</button>
      </div>
      <div id="sheetBody" class="sheetBody"></div>
    </div>
  </div>


  <script>
    // =========================
    // Data + Safety rails
    // =========================
    const INDEX_CANDIDATES = ["./index.json", "index.json", "./data/index.json", "data/index.json"];
    let INDEX_FILE_USED = null;
    let CURRENT_MODEL_ID = null;
    let CURRENT_DATASET_FILE = null;
    let CURRENT_MODEL_DISPLAY = null; // {make, label, years_label}

    const GENERIC_WORDS = [
      "bolt","bolts","screw","screws","nut","nuts","washer","washers",
      "pin","pins","clip","clips","fastener","fasteners",
      "torque","tightening","spec","specs","value","values"
    ];

    const MIN_SCORE_TO_ANSWER = 2;   // score too low → refuse
    const MIN_GAP_TO_ANSWER   = 2;   // best-second gap too small → ambiguous
    const MAX_CANDIDATES_UI   = 3;

    let torqueData = [];
    let bikeMeta = null;

    // Speech
    let recognition = null;
    let recognizing = false;

    // TTS
    let lastSpokenText = "";
    let lastSpokenEnabled = false;

    // DOM
    const badgeEl = document.getElementById("modelBadge");
    const statusLine = document.getElementById("statusLine");
    const micBig = document.getElementById("micBig");
    const questionInput = document.getElementById("questionInput");
    const sendBtn = document.getElementById("sendBtn");
    const resultBody = document.getElementById("resultBody");
    const repeatBtn = document.getElementById("repeatBtn");
    const stopBtn = document.getElementById("stopBtn");

    const modelMicBtn = document.getElementById("modelMicBtn");

    // Model voice switch (separate recognition session)
    let modelRecognition = null;
    let modelListening = false;


    // =========================
// Voice: Small MIC (model switch only)
// =========================
function initModelSpeech(){
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition){
        if (modelMicBtn) modelMicBtn.disabled = true;
        return null;
      }
      const r = new SpeechRecognition();
      r.lang = "en-US";
      r.interimResults = false;
      r.maxAlternatives = 1;

      r.onstart = ()=>{
        modelListening = true;
        if (modelMicBtn) modelMicBtn.classList.add("listening");
        setStatus("Listening for model…", true, false);
      };
      r.onerror = (ev)=>{
        modelListening = false;
        if (modelMicBtn) modelMicBtn.classList.remove("listening");
        setStatus("Model voice error: " + ev.error, true, true);
      };
      r.onend = ()=>{
        modelListening = false;
        if (modelMicBtn) modelMicBtn.classList.remove("listening");
        // If we were listening specifically for model, go back to ready
        if (statusLine && statusLine.textContent && statusLine.textContent.startsWith("Listening for model")){
          setStatus("Ready.", true, false);
        }
      };
      r.onresult = (ev)=>{
        const t = ev.results[0][0].transcript || "";
        handleModelVoice(t);
      };
      return r;
    }

    function normalizeModelCommand(text){
      let s = String(text || "").toLowerCase().trim();
      // common prefixes
      s = s.replace(/^hey\s+tesa[, ]*/i, "");
      s = s.replace(/^(switch|change|set|use)\s+(model\s+)?(to\s+)?/i, "");
      s = s.replace(/^model\s+(to\s+)?/i, "");
      // normalize punctuation/spaces
      s = s.replace(/[“”"']/g, "");
      s = s.replace(/\s+/g, " ").trim();
      return s;
    }

    function pickModelByVoice(text){
      if (!modelIndex) return { status:"NO_INDEX" };
      const q = normalizeModelCommand(text);
      if (!q) return { status:"EMPTY" };

      const models = flattenModels(modelIndex);

      let best = null;
      let bestScore = -1;
      let secondScore = -1;

      for (const m of models){
        const candidates = [];
        const make = String(m.make || "").toLowerCase().trim();
        const label = String(m.label || "").toLowerCase().trim();

        if (label) candidates.push(label);
        if (make && label) candidates.push((make + " " + label).trim());
        (m.aliases || []).forEach(a=>{
          const aa = String(a || "").toLowerCase().trim();
          if (aa) candidates.push(aa);
        });

        let localBest = -1;
        for (const a of candidates){
          // match if command contains alias OR alias contains command (handles short input like "v4s")
          if (q.includes(a) || a.includes(q)){
            // Score: prefer longer, more specific hits
            const score = 100 + Math.min(a.length, 60);
            if (score > localBest) localBest = score;
          }
        }

        if (localBest > bestScore){
          secondScore = bestScore;
          bestScore = localBest;
          best = m;
        } else if (localBest > secondScore){
          secondScore = localBest;
        }
      }

      if (!best || bestScore < 0) return { status:"NO_MATCH" };

      // Ambiguous if top scores tie closely (simple MVP rule)
      if (secondScore === bestScore){
        return { status:"AMBIGUOUS" };
      }

      return { status:"OK", model: best, query: q };
    }

    async function handleModelVoice(transcript){
      const picked = pickModelByVoice(transcript);

      if (picked.status === "NO_INDEX"){
        setStatus("Model list not loaded yet.", true, true);
        speak("Model list is not loaded yet.");
        return;
      }
      if (picked.status === "EMPTY"){
        setStatus("Say a model name, like V4S.", true, true);
        speak("Please say a model name, for example V4 S.");
        openSheet();
        return;
      }
      if (picked.status === "NO_MATCH"){
        setStatus("No model match. Tap to select.", true, true);
        speak("I couldn't find that model. Please tap to select.");
        renderSheet();
        openSheet();
        return;
      }
      if (picked.status === "AMBIGUOUS"){
        setStatus("Multiple model matches. Tap to select.", true, true);
        speak("Multiple model matches. Please tap to select.");
        renderSheet();
        openSheet();
        return;
      }

      // OK
      const m = picked.model;
      setStatus("Switching model…", true, false);
      await setCurrentModel(m.id, m.file, {speakConfirm:true});
      closeSheet();
}


    // Model index + selector UI
    const sheetOverlay = document.getElementById("sheetOverlay");
    const sheetBody = document.getElementById("sheetBody");
    const sheetClose = document.getElementById("sheetClose");

    let modelIndex = null; // loaded from INDEX_FILE

    function openSheet(){
      if (!sheetOverlay) return;
      sheetOverlay.classList.add("show");
    }
    function closeSheet(){
      if (!sheetOverlay) return;
      sheetOverlay.classList.remove("show");
    }

    function flattenModels(idx){
      const out = [];
      const mfgs = Array.isArray(idx?.manufacturers) ? idx.manufacturers : [];
      mfgs.forEach(mfg=>{
        const make = mfg?.make || mfg?.make_id || "Unknown";
        const make_id = mfg?.make_id || String(make).toLowerCase();
        const models = Array.isArray(mfg?.models) ? mfg.models : [];
        models.forEach(m=>{
          out.push({
            make,
            make_id,
            id: m?.id,
            label: m?.label || m?.model || m?.name || "Model",
            years_label: m?.years_label || (m?.years ? `${m.years.from}–${m.years.to}` : ""),
            file: m?.file,
            aliases: Array.isArray(m?.aliases) ? m.aliases : []
          });
        });
      });
      return out.filter(x=>x.id && x.file);
    }

    function renderSheet(){
      if (!sheetBody || !modelIndex) return;
      const models = flattenModels(modelIndex);

      // group by make
      const byMake = {};
      for (const m of models){
        byMake[m.make] = byMake[m.make] || [];
        byMake[m.make].push(m);
      }

      let html = "";
      Object.keys(byMake).sort().forEach(make=>{
        html += `<div class="makeLabel">${escapeHtml(make)}</div>`;
        byMake[make].forEach(m=>{
          const active = (m.id === CURRENT_MODEL_ID) ? "active" : "";
          const right = m.years_label ? `<span class="right">${escapeHtml(m.years_label)}</span>` : "";
          html += `
            <button class="modelBtn ${active}" type="button" data-model-id="${escapeHtml(m.id)}" data-file="${escapeHtml(m.file)}">
              <span><strong>${escapeHtml(m.label)}</strong></span>
              ${right}
            </button>
          `;
        });
      });

      sheetBody.innerHTML = html;

      // bind clicks
      sheetBody.querySelectorAll(".modelBtn").forEach(btn=>{
        btn.addEventListener("click", async ()=>{
          const id = btn.getAttribute("data-model-id");
          const file = btn.getAttribute("data-file");
          try{
            await setCurrentModel(id, file, {speakConfirm:true});
          } finally {
            closeSheet();
          }
        });
});
    }


    // =========================
// Model badge + bottom sheet UI
// =========================
function updateBadge(make, model, yearsLabel){
      badgeEl.classList.add("clickable");
      const y = yearsLabel ? (" · " + escapeHtml(String(yearsLabel))) : "";
      badgeEl.innerHTML = `<span class="dot"></span>${escapeHtml(String(make))} ${escapeHtml(String(model))}${y}`;
    }



    // =========================
// Model list (index.json) loading
// =========================
async function loadModelIndex(){
      const tried = [];
      const bust = `v=${Date.now()}`;

      for (const cand of INDEX_CANDIDATES){
        try{
          const url = new URL(cand, window.location.href);
          url.searchParams.set("v", String(Date.now()));

          tried.push(url.toString());
          setStatus("Loading model list…", true, false);

          const res = await fetch(url.toString(), { cache: "no-store" });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);

          modelIndex = await res.json();
          INDEX_FILE_USED = cand;
          return modelIndex;
        } catch(e){
          // continue
        }
      }

      console.error("index.json load failed. Tried:", tried);
      setStatus("Model list failed to load (index.json not found). Check that index.json is in the same folder as index.html.", true, true);
      throw new Error("index.json not found");
    }



    // =========================
// Dataset switching
// =========================
async function setCurrentModel(modelId, datasetFile, opts={}){
      CURRENT_MODEL_ID = modelId || null;
      CURRENT_DATASET_FILE = datasetFile || null;

      // Find display info from index.json if available
      const models = modelIndex ? flattenModels(modelIndex) : [];
      const m = models.find(x=>x.id === CURRENT_MODEL_ID) || null;

      if (m){
        CURRENT_MODEL_DISPLAY = { make: m.make, label: m.label, years_label: m.years_label };
      } else {
        CURRENT_MODEL_DISPLAY = { make: "Model", label: (CURRENT_MODEL_ID || "Unknown"), years_label: "" };
      }

      // Load dataset for selected model
      await loadTorqueData(CURRENT_DATASET_FILE);

      // After dataset load, re-apply badge from CURRENT_MODEL_DISPLAY (prevents any accidental overrides)
      if (CURRENT_MODEL_DISPLAY){
        updateBadge(CURRENT_MODEL_DISPLAY.make, CURRENT_MODEL_DISPLAY.label, CURRENT_MODEL_DISPLAY.years_label);

      // Reset UI to initial screen when switching dataset
      renderEmpty("Waiting for your question.");
      // Clear typed fallback input
      if (questionInput) questionInput.value = "";
      // Reset fallback text input as well
      if (fallbackInput) fallbackInput.value = "";
      }

      // Optional small voice confirmation (MVP-friendly)
      if (opts.speakConfirm && CURRENT_MODEL_DISPLAY){
        speak(`Switched to ${CURRENT_MODEL_DISPLAY.make} ${CURRENT_MODEL_DISPLAY.label}.`);
      }
    }



    // =========================
// App bootstrap
// =========================
async function initApp(){
      // Make badge interactive (tap to open sheet) even before fully ready.
      badgeEl.classList.add("clickable");

      // model list
      await loadModelIndex();

      // default model
      const defId = modelIndex?.default_model_id;
      const models = flattenModels(modelIndex);
      const def = models.find(x=>x.id === defId) || models[0];

      if (!def){
        throw new Error("No models found in index.json");

      // Defensive: re-apply badge shortly after init (prevents stale "Loading model…" UI)
      setTimeout(()=>{
        if (CURRENT_MODEL_DISPLAY){
          updateBadge(CURRENT_MODEL_DISPLAY.make, CURRENT_MODEL_DISPLAY.label, CURRENT_MODEL_DISPLAY.years_label);
        }
      }, 200);
      }

      // Populate sheet UI immediately
      renderSheet();

      // Switch to default model (loads dataset + applies badge)
      await setCurrentModel(def.id, def.file, {speakConfirm:false});

      // Ensure badge reflects selected model (defensive)
      if (CURRENT_MODEL_DISPLAY){
        updateBadge(CURRENT_MODEL_DISPLAY.make, CURRENT_MODEL_DISPLAY.label, CURRENT_MODEL_DISPLAY.years_label);
      }
    }

    function setStatus(text, active=false, isError=false){
      statusLine.textContent = text || "";
      statusLine.classList.toggle("active", !!active);
      statusLine.classList.toggle("error", !!isError);
    }

    function getSignificantWords(str){
      return String(str || "")
        .toLowerCase()
        .split(/[^a-z0-9]+/)
        .filter(w => w.length > 2 && !GENERIC_WORDS.includes(w));
    }

    async function loadTorqueData(datasetFile){

try{
  setStatus("Loading dataset…", true, false);
  let fileToLoad = datasetFile || CURRENT_DATASET_FILE;
  if (!fileToLoad){ throw new Error("No dataset selected"); }
  // Normalize relative path for GitHub Pages
  if (!/^https?:\/\//i.test(fileToLoad) && !fileToLoad.startsWith("./") && !fileToLoad.startsWith("/") ){
    fileToLoad = "./" + fileToLoad;
  }
  const res = await fetch(fileToLoad, { cache: "no-store" });
  if (!res.ok){
    throw new Error(`HTTP ${res.status} while fetching ${fileToLoad}`);
  }
  const data = await res.json();

  // Support both schemas:
  // (A) legacy: { manufacturer, model, year_start, year_end, torque_data: [...] }
  // (B) current: { dataset: { make, model, years:{from,to} }, items:[...] }
  const meta = extractDatasetMeta(data);
  bikeMeta = meta;
  torqueData = Array.isArray(meta.items) ? meta.items : [];

  const make = meta.make || "Unknown";
  const model = meta.model || "Model";
  const yFrom = meta.year_from ?? "";
  const yTo   = meta.year_to ?? "";  setStatus(`Ready. (${torqueData.length} items)`, true, false);
} catch (e){
  console.error(e);
  setStatus("Failed to load dataset. Use a local server (python http.server).", true, true);
}
    }



// -------------------------
// Schema helpers
// -------------------------
function extractDatasetMeta(data){
  // Current schema
  if (data && typeof data === "object" && data.dataset && Array.isArray(data.items)){
    const ds = data.dataset || {};
    const years = ds.years || {};
    return {
      make: ds.make ?? ds.manufacturer ?? ds.brand ?? "Unknown",
      model: ds.model ?? "Model",
      year_from: years.from ?? years.start ?? ds.year_start ?? "",
      year_to: years.to ?? years.end ?? ds.year_end ?? "",
      items: data.items
    };
  }

  // Legacy schema
  return {
    make: data?.manufacturer ?? data?.make ?? "Unknown",
    model: data?.model ?? "Model",
    year_from: data?.year_start ?? data?.year_from ?? "",
    year_to: data?.year_end ?? data?.year_to ?? "",
    items: Array.isArray(data?.torque_data) ? data.torque_data : []
  };
}

function splitList(val){
  if (val == null) return [];
  if (Array.isArray(val)) return val.map(x => String(x ?? "").trim()).filter(Boolean);
  return String(val)
    .split(/[;,]+/)
    .map(s => s.trim())
    .filter(Boolean);
}

// --- Torque helpers (support tightening_type + string/array torque_steps) ---
function parseTorqueStepsText(text){
  // Accept separators: newline or semicolon. Preserve user-entered content as much as possible.
  return String(text)
    .split(/\r?\n|;/)
    .map(s => s.trim())
    .filter(Boolean);
}

function getTorqueStepsRows(item){
  // Returns rows for UI in the form [{label, value}] for multi-step; [] otherwise.
  const tt = (item && item.tightening_type ? String(item.tightening_type).trim().toLowerCase() : "");
  if (tt !== "multi_step") return [];

  // If torque_steps is an array of objects (structured), keep existing behavior.
  if (Array.isArray(item.torque_steps) && item.torque_steps.length){
    return item.torque_steps.map((s, idx) => {
      const rawLabel = (s.step != null ? String(s.step) : String(idx + 1)).trim();
      const parts = [];
      if (s.torque_nm != null) parts.push(`${s.torque_nm} Nm`);
      if (s.angle_deg != null) parts.push(`+ ${s.angle_deg}°`);
      const value = parts.length ? parts.join(" ") : (s.raw || "Follow manual");
      return { label: rawLabel, value };
    });
  }

  // If torque_steps is a string, parse lines into rows.
  if (item.torque_steps != null && String(item.torque_steps).trim()){
    const lines = parseTorqueStepsText(item.torque_steps);
    return lines.map((line, idx) => {
      // If the line already has a label (e.g., "Step 1: 5 Nm"), keep it.
      const parts = line.split(":");
      if (parts.length >= 2){
        const label = parts.shift().trim();
        const value = parts.join(":").trim();
        return { label: label || String(idx + 1), value: value || "Follow manual" };
      }
      return { label: String(idx + 1), value: line };
    });
  }

  return [];
}

// --- Multi-step vs Multi-size classification (string torque_steps) ---
function classifyTorqueStepsRows(rows){
  // Returns "multi_step" or "multi_size" (default multi_step)
  if (!Array.isArray(rows) || !rows.length) return "multi_step";
  const labels = rows.map(r => String(r?.label ?? "").trim());
  const allSize = labels.length > 0 && labels.every(l => /^m\d+$/i.test(l));
  if (allSize) return "multi_size";

  const allStep = labels.length > 0 && labels.every(l => /^step\s*\d+$/i.test(l) || /^step\d+$/i.test(l) || /^\d+$/.test(l));
  if (allStep) return "multi_step";

  // Mixed/unknown → treat as multi_step (safer)
  return "multi_step";
}

function normalizeStepLabel(label){
  let s = String(label ?? "").trim();
  if (!s) return "";
  // "1" -> "STEP1", "Step 1" -> "STEP1", "Step1" -> "STEP1"
  const m = s.match(/(\d+)/);
  if (m) return `STEP${m[1]}`;
  return s.toUpperCase();
}

function normalizeSizeLabel(label){
  const s = String(label ?? "").trim();
  return s ? s.toUpperCase() : "";
}

function extractNmNumber(text){
  // Returns string number ONLY when an explicit "Nm" unit is present.
  // Prevents angle-only steps like "100°" from being treated as "100 Nm".
  const s = String(text ?? "");
  const m = s.match(/(-?\d+(?:\.\d+)?)\s*nm\b/i);
  return m ? m[1] : null;
}

function formatTorqueValueHtml(valueText){
  const s = String(valueText ?? "");

  // Angle-only step (e.g., "100°") should display degrees, not Nm.
  const deg = s.match(/(-?\d+(?:\.\d+)?)\s*°/);
  const hasNm = /\bnm\b/i.test(s);

  if (deg && !hasNm){
    return `<span class="stepNum">${escapeHtml(deg[1])}</span><span class="stepUnit">°</span>`;
  }

  const num = extractNmNumber(s);
  if (!num) return escapeHtml(s);
  return `<span class="stepNum">${escapeHtml(num)}</span><span class="stepUnit">Nm</span>`;
}

function getTorqueStepsForSpeech(item){
  // Returns an array of objects compatible with the speech builder:
  // [{ step, torque_nm?, angle_deg?, raw? }]
  const tt = (item && item.tightening_type ? String(item.tightening_type).trim().toLowerCase() : "");
  if (tt !== "multi_step") return [];

  if (Array.isArray(item.torque_steps) && item.torque_steps.length){
    return item.torque_steps;
  }
  if (item.torque_steps != null && String(item.torque_steps).trim()){
    const lines = parseTorqueStepsText(item.torque_steps);
    return lines.map((line, idx) => ({ step: String(idx + 1), raw: line }));
  }
  return [];
}


function getExtraNotesList(item){
  const v = item?.extra_notes;
  if (v == null) return [];
  if (Array.isArray(v)) return v.map(x => String(x ?? "").trim()).filter(Boolean);
  const s = String(v).trim();
  return s ? [s] : [];
}


function getSpecialTools(item){
  // Preferred: array of objects [{special_tool_name, special_tool_number}, ...]
  if (Array.isArray(item?.special_tools)){
    return item.special_tools.map(t => ({
      special_tool_name: (t?.special_tool_name ?? t?.name ?? "").toString().trim(),
      special_tool_number: (t?.special_tool_number ?? t?.number ?? t?.tool_number ?? "").toString().trim()
    })).filter(t => t.special_tool_name || t.special_tool_number);
  }

  // Current dataset fields: special_tool_numbers / special_tool_name (strings)
  const nums = splitList(item?.special_tool_numbers ?? item?.special_tool_number ?? item?.tool_number);
  const names = splitList(item?.special_tool_name ?? item?.special_tool_names ?? item?.tool_name);

  const out = [];
  const n = Math.max(nums.length, names.length);
  for (let i=0; i<n; i++){
    out.push({
      special_tool_name: names[i] || "",
      special_tool_number: nums[i] || ""
    });
  }
  return out.filter(t => t.special_tool_name || t.special_tool_number);
}

function scoreItem(queryLower, qSig, item){
      let textParts = [];
      if (item.component_name) textParts.push(item.component_name);
      if (Array.isArray(item.common_name)) textParts.push(item.common_name.join(" "));
      const fullText = textParts.join(" ").toLowerCase();
      if (!fullText) return 0;

      // hit count
      let hits = 0;
      for (const w of qSig) if (fullText.includes(w)) hits++;
      let score = hits;

      // component_name bonus
      if (item.component_name){
        const cn = item.component_name.toLowerCase();
        if (queryLower === cn) score += 5;
        else if (queryLower.includes(cn) || cn.includes(queryLower)) score += 2;
      }

      // common_name bonus
      if (Array.isArray(item.common_name)){
        for (const aRaw of item.common_name){
          const a = String(aRaw || "").toLowerCase();
          if (!a) continue;
          if (queryLower === a) score += 4;
          else if (queryLower.includes(a) || a.includes(queryLower)) score += 1;
        }
      }
      return score;
    }

    function findCandidates(query){
      const qLower = query.toLowerCase();
      const qSig = getSignificantWords(query);
      if (!qSig.length) return [{__special:"NO_SIG_WORDS"}];

      const scored = [];
      for (const item of torqueData){
        const s = scoreItem(qLower, qSig, item);
        if (s > 0) scored.push({item, score:s});
      }
      scored.sort((a,b)=>b.score-a.score);
      return scored;
    }

    // =========================
    // Result rendering (voice-first)
    // =========================
    function renderEmpty(text){
      resultBody.className = "empty";
      resultBody.innerHTML = text;
      setRepeatStop(false);
    }

    function setRepeatStop(enabled){
      repeatBtn.disabled = !enabled;
      stopBtn.disabled = !enabled;
      lastSpokenEnabled = enabled;
    }

    function stopSpeak(){
      if ("speechSynthesis" in window){
        window.speechSynthesis.cancel();
      }
    }

    function speak(text){
      lastSpokenText = text || "";
      setRepeatStop(!!lastSpokenText);

      if (!("speechSynthesis" in window) || !text) return;
      stopSpeak();
      const u = new SpeechSynthesisUtterance(text);
      u.lang = "en-US";
      u.rate = 1.0;
      u.pitch = 1.0;
      window.speechSynthesis.speak(u);
    }

    function speakNumbersDigitByDigit(text){
      if (text == null) return "";
      const s = String(text);

      // 문자열 안의 연속 숫자(\d+)만 찾아서 "2 4 3" 형태로 변환
      return s.replace(/\d+/g, (num) => num.split("").join(" "));
    }

function buildSpokenAnswerParts(item){
  if (!item) return { base:"No matching fastener found.", info:"" };

  const name = item.component_name || "this fastener";
  const tt = (item.tightening_type ? String(item.tightening_type).trim().toLowerCase() : "");

  const baseParts = [];
  const infoParts = [];

  // Part name first
  baseParts.push(`${name}.`);

  // -----------------------
  // Torque / tightening
  // -----------------------
  if (tt === "multi_step"){
    const rows = getTorqueStepsRows(item);
    const caseType = classifyTorqueStepsRows(rows);

    if (rows.length){
      if (caseType === "multi_size"){
        baseParts.push("Torque by size.");
        rows.forEach(r=>{
          const size = normalizeSizeLabel(r.label);
          const nm = extractNmNumber(r.value);
          const degMatch = String(r.value ?? "").match(/(\d+(?:\.\d+)?)\s*°/);
          const deg = degMatch ? degMatch[1] : null;

          if (nm && deg){
            baseParts.push(`${size}. ${nm} newton meters, plus ${deg} degrees.`);
          } else if (nm){
            baseParts.push(`${size}. ${nm} newton meters.`);
          } else {
            baseParts.push(`${size}. ${String(r.value ?? "").trim()}.`);
          }
        });
      } else {
        // Multi-Step case
        rows.forEach(r=>{
          const stepTag = normalizeStepLabel(r.label); // STEP1
          const stepNumMatch = stepTag.match(/STEP(\d+)/i);
          const stepNum = stepNumMatch ? stepNumMatch[1] : "";
          const nm = extractNmNumber(r.value);
          const degMatch = String(r.value ?? "").match(/(\d+(?:\.\d+)?)\s*°/);
          const deg = degMatch ? degMatch[1] : null;

          const spokenLabel = stepNum ? `Step ${stepNum}` : "Step";
          if (nm && deg){
            baseParts.push(`${spokenLabel}. ${nm} newton meters, then add ${deg} degrees.`);
          } else if (nm){
            baseParts.push(`${spokenLabel}. ${nm} newton meters.`);
          } else {
            baseParts.push(`${spokenLabel}. ${String(r.value ?? "").trim()}.`);
          }
        });
      }
    } else {
      baseParts.push("Torque is not specified in this dataset.");
    }
  } else {
    // Single (or unknown → treat like single)
    if (item.torque_nm_single != null && String(item.torque_nm_single).trim() !== ""){
      baseParts.push(`${item.torque_nm_single} newton meters.`);
    } else {
      baseParts.push("Torque is not specified in this dataset.");
    }
  }

  // -----------------------
  // Chemistry (values only)
  // -----------------------
  const chemVals = [];

  if (item.threadlock) {
    chemVals.push(speakNumbersDigitByDigit(item.threadlock));
  }
  const lubeSpoken = item.lubrication_symbol || item.lubrication;
  if (lubeSpoken) {
    chemVals.push(String(lubeSpoken));
  }
  if (item.sealant) {
    chemVals.push(speakNumbersDigitByDigit(item.sealant));
  }
  if (chemVals.length) {
    baseParts.push(`Apply ${chemVals.join(", ")}.`);
  }

  // -----------------------
  // Info block (spoken only when user says YES)
  // -----------------------
  const tools = getSpecialTools(item);
  if (tools.length){
    tools.forEach(t => {
      const toolName = (t?.special_tool_name ?? "").toString().trim();
      const toolNum  = (t?.special_tool_number ?? "").toString().trim();

      if (toolName){
        infoParts.push(`${toolName} is required.`);
      } else if (toolNum){
        infoParts.push(`Special tool ${toolNum} is required.`);
      }
    });
  }

  if (item.tightening_seq){
    const seq = String(item.tightening_seq).trim();
    if (seq) infoParts.push(/[.?!]$/.test(seq) ? seq : (seq + "."));
  }

  const notes = getExtraNotesList(item);
  if (notes.length){
    notes.forEach(note => {
      const n = String(note || "").trim();
      if (!n) return;
      infoParts.push(/[.?!]$/.test(n) ? n : (n + "."));
    });
  }

  return {
    base: baseParts.join(" "),
    info: infoParts.join(" ")
  };
}



    function renderResult(item, info){
      const name = item.component_name || "Unknown fastener";

      // ----- Chemistry line (threadlock / lube / sealant) -----
      const chemItems = [];
      if (item.threadlock)  chemItems.push({k:"Threadlock", v:item.threadlock});

        // ✅ show symbol instead of full lubrication text
      const lubeDisplay = item.lubrication_symbol || item.lubrication;
      if (lubeDisplay) chemItems.push({k:"Lubrication", v:lubeDisplay});

      if (item.sealant)     chemItems.push({k:"Sealant", v:item.sealant});

      // ----- Steps normalize (by tightening_type) -----
      const rows = getTorqueStepsRows(item);

      const isBoltSizeVariant =
        rows.length > 0 &&
        rows.every(r => /^m\d+$/i.test(r.label));

      const hasSingle = (item.torque_nm_single != null);

      // ----- Pills: Type, Thread, Group, Score (in that order) -----
      const pills = [];

      // Type
      const tt = (item.tightening_type ? String(item.tightening_type).toLowerCase() : "");
      if (tt === "multi_step") pills.push("Type: multi");
      else if (tt === "single" || hasSingle) pills.push("Type: single");

      // Thread
      if (item.thread_spec) pills.push(`Thread: ${item.thread_spec}`);

      // Group
      if (item.group) pills.push(`Group: ${item.group}`);

      // Score
      if (info && typeof info.bestScore === "number") pills.push(`Score: ${info.bestScore}`);

      // ----- Special tools + Extra notes (new block) -----
      const toolLines = [];
      const _toolsForScreen = getSpecialTools(item);
      if (_toolsForScreen.length){
        _toolsForScreen.forEach(t=>{
          const toolName = (t?.special_tool_name ?? "").toString().trim();
          const toolNum  = (t?.special_tool_number ?? "").toString().trim();

          // Screen exposure rules:
          // - name+number: "name - number"
          // - name only: "name"
          // - number only: "number"
          if (toolName && toolNum) toolLines.push(`${toolName} - ${toolNum}`);
          else if (toolName) toolLines.push(`${toolName}`);
          else if (toolNum) toolLines.push(`${toolNum}`);
        });
      }
      const extraNotes = getExtraNotesList(item);

      // ----- Build HTML -----
      let html = `<div class="partName">${escapeHtml(name)}</div>`;

      // ✅ multi-step: show steps in the single-torque area
      if (rows.length){
        html += `<div class="stepList multi" style="margin-top:8px;padding-top:0;border-top:none;">`;

        const caseType = classifyTorqueStepsRows(rows);

        rows.forEach(r => {
          let tag = r.label;

          if (caseType === "multi_size"){
            tag = normalizeSizeLabel(tag);
          } else {
            // multi_step
            tag = normalizeStepLabel(tag);
          }

          html += `
            <div class="stepRow">
              <div class="stepTag">${escapeHtml(tag)}</div>
              <div class="stepVal">${formatTorqueValueHtml(r.value)}</div>
            </div>
          `;
        });

        html += `</div>`;
      } else {
        // ✅ single: big torque number only (no "Single torque" line)
        if (hasSingle){
          html += `
            <div class="torqueBig">
              ${escapeHtml(String(item.torque_nm_single))}<span class="torqueUnit">Nm</span>
            </div>
          `;
        } else {
          html += `
            <div class="torqueBig">—</div>
          `;
        }
      }

      // Chemistry line (threadlock/lube/sealant)
      if (chemItems.length){
        html += `<div class="chemLine">` + chemItems.map(ci => (
          `<div class="chemItem"><span class="chemKey">${escapeHtml(ci.k)}:</span> ${escapeHtml(ci.v)}</div>`
        )).join("") + `</div>`;
      }

      // ✅ Info block (Special tool → Tightening sequence → Extra notes)
      const _toolsForInfo = getSpecialTools(item);
      const hasToolDataForInfo = _toolsForInfo.length > 0;
      const hasSeqDataForInfo  = !!(item.tightening_seq && String(item.tightening_seq).trim());
      const hasNoteDataForInfo = getExtraNotesList(item).length > 0;
      const hasInfoBlock = (hasToolDataForInfo || hasSeqDataForInfo || hasNoteDataForInfo);

if (hasInfoBlock){
        html += `<div class="infoBlock" id="infoBlock">`;

        // 1) Special tool
        const _toolsInfo = getSpecialTools(item);
        if (_toolsInfo.length){
          const toolLines = _toolsInfo.map(t=>{
            const toolName = (t?.special_tool_name ?? "").toString().trim();
            const toolNum  = (t?.special_tool_number ?? "").toString().trim();
            if (toolName && toolNum) return `${toolName} - ${toolNum}`;
            if (toolName) return `${toolName}`;
            if (toolNum) return `${toolNum}`;
            return "";
          }).filter(Boolean);

          if (toolLines.length){
            html += `<div class="infoLine"><span class="infoKey">Special tool:</span> ${escapeHtml(toolLines.join(", "))}</div>`;
          }
        }

        // 2) Tightening sequence
        if (item.tightening_seq){
          html += `<div class="infoLine"><span class="infoKey">Sequence:</span> ${escapeHtml(String(item.tightening_seq))}</div>`;
        }

        // 3) Extra notes
        const _notesForScreen = getExtraNotesList(item);
        if (_notesForScreen.length){
          _notesForScreen.forEach(n=>{
            html += `<div class="infoLine"><span class="infoKey">Note:</span> ${escapeHtml(n)}</div>`;
          });
        }

        html += `</div>`;
      }


      // ----- Item number + reference images (between infoBlock and pills) -----
      const itemNumber = (item?.item_number ?? "").toString().trim();
      if (itemNumber){
        html += `<div class="itemNumber"><span class="itemLabel">Ref. image:</span>${escapeHtml(itemNumber)}</div>`;
      }

      let refImgs = [];
      if (Array.isArray(item?.ref_images)) {
        refImgs = item.ref_images;
      } else if (typeof item?.ref_image === "string") {
        refImgs = item.ref_image.split(";");
      }
      refImgs = (refImgs || []).map(x => (x ?? "").toString().trim()).filter(Boolean);

      if (refImgs.length){
        html += `<div class="refImages">` +
          refImgs.map(fn => `<img class="refImage" src="${getRefImageUrl(fn)}" alt="Reference image">`).join("") +
          `</div>`;
      }

      // Meta pills
      if (pills.length){
        html += `<div class="metaRow">` + pills.map(p=>(
          `<span class="meta"><span class="mDot"></span>${escapeHtml(p)}</span>`
        )).join("") + `</div>`;
      }


      resultBody.className = "";
      const spoken = buildSpokenAnswerParts(item);
resultBody.className = "";
      resultBody.innerHTML = html;
      // Always speak base + info (info gate removed)
      const fullSpeech = spoken.info ? `${spoken.base} ${spoken.info}` : spoken.base;
      speak(fullSpeech);

}

    function renderAmbiguous(cands, info){
      resultBody.className = "";
      const top = cands.slice(0, MAX_CANDIDATES_UI);
      let html = `
        <div class="partName">Multiple matches</div>
        <div class="subLine">Tap the correct one (safer than guessing).</div>
      `;

      if (info && typeof info.bestScore === "number"){
        html += `<div class="metaRow">
          <span class="meta"><span class="mDot"></span>Score: ${escapeHtml(String(info.bestScore))}</span>
          <span class="meta"><span class="mDot"></span>Gap: ${escapeHtml(String(info.gap))}</span>
        </div>`;
      }

      html += `<div class="candidates">` + top.map(({item, score})=>{
        const title = item.component_name || item.id || "Candidate";
        const group = item.group ? ` · ${item.group}` : "";
        return `<button class="candBtn" type="button" data-id="${escapeHtml(String(item.id || ""))}">
          <strong>${escapeHtml(title)}</strong>
          <span class="candSub">Select (score ${escapeHtml(String(score))})${escapeHtml(group)}</span>
        </button>`;
      }).join("") + `</div>`;

      resultBody.innerHTML = html;
      setRepeatStop(false);
      speak("Multiple matches. Please select the correct fastener on the screen.");

      // bind
      const btns = resultBody.querySelectorAll(".candBtn");
      btns.forEach((b, idx)=>{
        b.addEventListener("click", ()=>{
          const chosen = top[idx];
          if (chosen && chosen.item) renderResult(chosen.item, {bestScore: chosen.score});
        });
      });
    }


    // =========================

function getRefImageUrl(filename){
      const fn = (filename ?? "").toString().trim();
      if (!fn) return "";
      // If dataset already provides a full/relative path, respect it.
      if (/^https?:\/\//i.test(fn) || fn.startsWith("/") || fn.startsWith("./")) return fn;

      // Build base from CURRENT_DATASET_FILE (e.g. datasets/<model>/dataset.json -> datasets/<model>/images/)
      const df = (CURRENT_DATASET_FILE ?? "").toString();
      const slash = df.lastIndexOf("/");
      const baseDir = (slash >= 0) ? df.slice(0, slash + 1) : "";
      const imgBase = baseDir + "images/";
      return imgBase + encodeURIComponent(fn);
    }

// Utilities
// =========================
function escapeHtml(s){
      return String(s ?? "")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    function normalizeQuery(q){
      let s = String(q || "").toLowerCase();

      const glueMap = {
        "subframe": "sub frame",
        "swingarm": "swing arm",
        "headstock": "head stock",
        "oilpan": "oil pan",
        "wheelbase": "wheel base"
      };

      for (const [k,v] of Object.entries(glueMap)){
        s = s.replaceAll(k, v);
      }

      return s;
    }

    // =========================
    // Query handler (uses safety rails)
    // =========================

    // =========================
// Torque query + rendering
// =========================
function handleQuery(raw){
      const q = String(raw || "").trim();
      const nq = normalizeQuery(q);
      if (!q){
        setStatus("Say a part name, or type in the box.", true, true);
        renderEmpty("Waiting for your question.");
        return;
      }
      if (!torqueData.length){
        setStatus("Dataset not loaded yet.", true, true);
        renderEmpty("Dataset not loaded yet.");
        return;
      }

      setStatus("Searching…", true, false);

      const candidates = findCandidates(nq);

      // Rail #1: too generic
      if (candidates.length && candidates[0].__special === "NO_SIG_WORDS"){
        setStatus("Too generic. Add a part name.", true, true);
        renderEmpty("Too generic. Include a part name (example: “rear brake caliper”).");
        speak("Too generic. Please include a part name, for example: rear brake caliper.");
        return;
      }

      // No candidates
      if (!candidates.length){
        setStatus("No match in dataset.", true, true);
        renderEmpty("No match. This part may not be in the current dataset.");
        speak("No matching fastener found. This part may not be in the current dataset.");
        return;
      }

      const best = candidates[0];
      const second = candidates[1] || null;
      const bestScore = best.score;
      const gap = second ? (best.score - second.score) : best.score;

      // Rail #2: low score → refuse
      if (bestScore < MIN_SCORE_TO_ANSWER){
        setStatus("Low confidence. Be more specific.", true, true);
        renderEmpty("No confident match. Try a more specific part name (add location/system).");
        speak("No confident match. Try a more specific part name.");
        return;
      }

      // Rail #3: ambiguous → user choose
      if (second && gap < MIN_GAP_TO_ANSWER){
        setStatus("Ambiguous. Select the correct one.", true, true);
        renderAmbiguous(candidates, {bestScore, gap});
        return;
      }

      // Confident
      setStatus("Match found.", true, false);
      renderResult(best.item, {bestScore, gap});
    }

    // =========================
    // Events
    // =========================
    sendBtn.addEventListener("click", ()=> handleQuery(questionInput.value));
    questionInput.addEventListener("keydown", (e)=>{
      if (e.key === "Enter"){
        e.preventDefault();
        handleQuery(questionInput.value);
      }
    });

    repeatBtn.addEventListener("click", ()=>{
      if (lastSpokenEnabled && lastSpokenText) speak(lastSpokenText);
    });
    stopBtn.addEventListener("click", ()=>{
      stopSpeak();
    });




    // Model badge tap -> open selector
    badgeEl.addEventListener("click", ()=>{
      if (!modelIndex) return;
      renderSheet();
      openSheet();
    });
    sheetClose.addEventListener("click", closeSheet);
    sheetOverlay.addEventListener("click", (e)=>{
      if (e.target === sheetOverlay) closeSheet();
    });

    // Small mic button -> listen for a model switch command (e.g., "Switch to V4S")
    if (modelMicBtn){
      modelMicBtn.addEventListener("click", ()=>{
        if (!modelIndex){
          speak("Model list is not loaded yet.");
          return;
        }
        if (!modelRecognition) modelRecognition = initModelSpeech();
        if (!modelRecognition) {
          speak("Speech recognition is not supported here.");
          return;
        }
        if (modelListening){
          modelRecognition.stop();
          return;
        }
        modelRecognition.start();
      });
    }
// Speech recognition (desktop chrome)

    // =========================
// Voice: Big MIC (torque query only)
// =========================
function initSpeech(){
      const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
      if (!SpeechRecognition){
        micBig.disabled = true;
        setStatus("Speech recognition not supported here (iPhone Safari limitation). Use keyboard mic.", true, true);
        return;
      }
      recognition = new SpeechRecognition();
      recognition.lang = "en-US";
      recognition.interimResults = false;
      recognition.maxAlternatives = 1;

      recognition.onstart = ()=>{
        recognizing = true;
        setStatus("Listening…", true, false);
      };
      recognition.onerror = (ev)=>{
        recognizing = false;
        setStatus("Speech error: " + ev.error, true, true);
      };
      recognition.onend = ()=>{
        recognizing = false;
        setStatus("Ready.", true, false);
      };
      recognition.onresult = (ev)=>{
        const t = ev.results[0][0].transcript;
        questionInput.value = t;
        handleQuery(t);
      };
    }

    micBig.addEventListener("click", ()=>{
      if (!recognition) initSpeech();
      if (!recognition) return;

      if (recognizing){
        recognition.stop();
        return;
      }
      recognition.start();
    });

    // Init
    renderEmpty("Waiting for your first question.");
    setStatus("");
    initApp().catch((e)=>{ console.error(e); });
</script>
</body>
</html>
